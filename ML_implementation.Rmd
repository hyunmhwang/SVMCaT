---
title: "ML_implementation"
author: "Hyun Hwang"
date: "04/24/2020"
output: pdf_notebook
---


``` {r}
library(tidyverse)
library(e1071)
library(glmnet)
library(MASS)
library(caret)
library(ggplot2)
library(reshape2)
library(readr)
library(readxl)
library(dplyr)
library(pROC)
options(stringsAsFactors = FALSE)


source("~/Desktop/Files/1/R/ML_project/Rscripts/2020_ml_github/Rfuncs_HH.r")
```


### training svm_fit_model for peak status prediction
```{r}
## loading peak training data
set.seed(2019)
TrainData <- read_csv("~/Desktop/Files/1/R/ML_project/Results/TrainData.csv")
TrainData$peak_status_expert <- factor(TrainData$peak_status_expert, levels = c("abnormal", "normal"))
is.factor(TrainData$peak_status_expert)


## 15 peak-level variables 
var_list = c("A_l", "A_r", "A_d", "D_l", "D_r", 
             "Dy_max", "Dy_min", "D2y_max", "D2y_min", "R", 
             "delta", "delta_l2Dymax", "delta_m2Dymin", "Peak_distance", "Peak_distance_median")


## standardization of training peak-level variables
TrainData[, eval(var_list)] <- TrainData %>% dplyr::select(eval(var_list)) %>% scale()
nrow(TrainData) #1893


## training svm_fit_peak
svm_fit_peak = svm(peak_status_expert ~ peak_status_analytical_algorithm + 
                      A_l + A_r + A_d + D_l + D_r + Dy_max + Dy_min + 
                      D2y_max + D2y_min + R + delta + delta_l2Dymax + delta_m2Dymin +
                      Peak_distance + Peak_distance_median, 
                    data = TrainData, 
                    type = "C-classification",
                    kernel = "radial", 
                    scale = FALSE)

```


### svm_fit_peak application to novel data 
```{r}
## loading peak novel data
peak_info_novel = read_csv("~/Desktop/Files/1/R/ML_project/Results/peak_info_novel.csv", col_types = cols(X1=col_skip()))
table(peak_info_novel$peak_status_analytical_algorithm) 
#abnormal   normal 
#     124      330 


## standardization of novel peak-level variables
peak_info_novel[, eval(var_list)] <- scale(peak_info_novel[, eval(var_list)])


## novel peak status prediction using svm_fit_peak
peak_svm = as.vector(predict(svm_fit_peak, newdata = peak_info_novel))
peak_info_novel$peak_svm <- peak_svm


## loading novel peak_status_expert and mering with peak_info_novel
novel_peak_expert <- read_xlsx("~/Desktop/Files/1/R/ML_project/Data/novel_peak_expert.xlsx")
novel_peak_expert$peak_id <- str_remove(novel_peak_expert$peak_id, "_")
colnames(novel_peak_expert)[3] <- "peak_status_expert"
peak_dt <- merge(novel_peak_expert, peak_info_novel, by = c("cell_id", "peak_id"), sort = FALSE)
peak_dt %>% dplyr::select(peak_status_analytical_algorithm, peak_svm) %>% table
#           peak_svm
#peak_status abnormal normal
#   abnormal      124      0
#   normal          5    325


## novel peak data confusion matrix analysis of peak_status_analytical vs peak_status_expert
confusionMatrix(factor(peak_dt$peak_status_analytical_algorithm), factor(peak_dt$peak_status_expert))
#          Reference
#Prediction abnormal normal
#  abnormal       76     48
#  normal          6    324
#               Accuracy : 0.8811          
#            Sensitivity : 0.9268          
#            Specificity : 0.8710          


## novel peak data confusion matrix analysis of peak_status_svm vs peak_status_expert
confusionMatrix(factor(peak_dt$peak_svm), factor(peak_dt$peak_status_expert))
#          Reference
#Prediction abnormal normal
#  abnormal       76     53
#  normal          6    319
#               Accuracy : 0.87
#            Sensitivity : 0.9268          
#            Specificity : 0.8575          


## Based on MLpredPeak or PeakIdentify, produce cell_status_analytical_algorithm_or_svm
novel_pred_abnormal_cell <- peak_dt %>% dplyr::filter(peak_svm == "abnormal") %>% dplyr::select(cell_id) %>% unique() %>% unlist()
novel_pred_normal_cell <- peak_info_novel %>% dplyr::filter(! cell_id %in% novel_pred_abnormal_cell)  %>% dplyr::select(cell_id) %>% unique() %>% unlist()
novel_cell_pred <- data.frame(cell_id = c(novel_pred_abnormal_cell, novel_pred_normal_cell), 
    peak_status_analytical_algorithm_or_svm = c(rep("abnormal", length(novel_pred_abnormal_cell)), rep("normal", length(novel_pred_normal_cell))))

```

### svm_fit_cell application to novel data 
```{r}
## Cell-level variables extracted from scaled peak-level variables
Cell_var <- TrainData %>% group_by(cell_id) %>% summarise(n_peak = n(), 
                                                          n_abnormal = sum(peak_status_analytical_algorithm_or_svm == "abnormal"), 
                                                          var_A = var( (A_l + A_r)/2 ), 
                                                          var_delta = get_delta.var(delta), 
                                                          var_R = var(R))
colnames(Cell_var)[1] = "cell_id"
cell_var_list = c("n_peak", "n_abnormal", "var_A", "var_delta", "var_R")
Cell_var[, eval(cell_var_list)] <- scale(Cell_var[, eval(cell_var_list)])


## novel cell-level variables
Cell_dt <- read_csv("~/Desktop/Files/1/R/ML_project/Results/Cell_dt.csv", col_types = cols(X1=col_skip())) %>% dplyr::select(c(cell_id, peak_status_analytical_algorithm_or_svm, cell_status_expert))
Cell_dt$peak_status_analytical_algorithm_or_svm = factor(Cell_dt$peak_status_analytical_algorithm_or_svm)
Cell_dt$cell_status_expert = factor(Cell_dt$cell_status_expert)
Cell_dt <- merge(Cell_dt, Cell_var, by = "cell_id")


# Train data accuracy
confusionMatrix(Cell_dt$peak_status_analytical_algorithm_or_svm, Cell_dt$cell_status_expert)
#         Reference
#Prediction bad good
#      bad  107   14
#      good   7   70
#               Accuracy : 0.8939          
#            Sensitivity : 0.9386          
#            Specificity : 0.8333          


svm_fit_cell = svm(formula = cell_status_expert ~ 
                     peak_status_analytical_algorithm_or_svm + n_peak + 
                     n_abnormal + var_A + var_delta + var_R, 
                   data = Cell_dt, 
                   type = "C-classification",
                   kernel = "radial", 
                   scale = FALSE,
                   probability = TRUE)


pred_cell = predict(svm_fit_cell, newdata=Cell_dt)
confusionMatrix(factor(pred_cell), Cell_dt$cell_status_expert)
#          Reference
#Prediction bad good
#      bad  108   14
#      good   6   70
#               Accuracy : 0.899           
#            Sensitivity : 0.9474          
#            Specificity : 0.8333          


### Cell variables for test data
novel_cell_var <- peak_info_novel %>% group_by(cell_id) %>% summarise(n_peak = n(), 
                                                                      n_abnormal = sum(peak_svm == "abnormal"), 
                                                                      var_A = var( (A_l + A_r)/2 ), 
                                                                      var_delta = get_delta.var(delta), 
                                                                      var_R = var(R)) 


colnames(novel_cell_var)[1] = "cell_id" 
novel_cell_var[, eval(cell_var_list)] = scale(novel_cell_var[, eval(cell_var_list)])


novel_cell_dt <- novel_cell_pred %>% merge(novel_cell_var, by = "cell_id", sort = FALSE)
novel_cell_dt$peak_status_analytical_algorithm_or_svm <- factor(novel_cell_dt$peak_status_analytical_algorithm_or_svm)


## Merge with expert assessment
novel_cell_expert <- read_xlsx("~/Desktop/Files/1/R/ML_project/Data/novel_cell_expert.xlsx")
colnames(novel_cell_expert)[1] = "cell_id"
novel_cell_dt <- merge(novel_cell_dt, novel_cell_expert, by = "cell_id")


## Cell status prediction by SVM
novel_cell_dt$cell_status_svm = as.vector(predict(svm_fit_cell, newdata=novel_cell_dt))


confusionMatrix(factor(novel_cell_dt$cell_status_svm), factor(novel_cell_dt$expert_status)) 
#          Reference
#Prediction bad good
#      bad   32    3
#      good  4   15
#               Accuracy : 0.8704           
#            Sensitivity : 0.8889           
#            Specificity : 0.8333  


confusionMatrix(factor(novel_cell_dt$peak_status_analytical_algorithm_or_svm), factor(novel_cell_dt$expert_status)) 
#          Reference
#Prediction bad good
#      bad   32    3
#      good   4   15
#               Accuracy : 0.8704         
#            Sensitivity : 0.8889         
#            Specificity : 0.8333         


```


### Plot cell intensities with peak_status_analytical_algorithm_or_svm and cell_2status_expert
```{r}
## Load data
fluo4_data_novel <- read_csv("~/Desktop/Files/1/R/Calcium_imaging/After_sorting/112119_Lemon/112119_ca0_1.csv")
names(fluo4_data_novel)[1] <- "Well"
names(fluo4_data_novel)[2] <- "cell_id"

data_with_status_60_novel = merge(novel_cell_dt[, 
                c("cell_id", "cell_status_svm", 
                  "expert_status")], 
                fluo4_data_novel, by = c("cell_id"))


pdf("~/Desktop/Files/1/R/ML_project/Results/Signals_with_PredExpStatus_novel.pdf")
Lane_list = sort(unique(data_with_status_60_novel$Well))
for(lane in Lane_list){
  temp = data_with_status_60_novel[data_with_status_60_novel$Well == lane, ]
  plot_data = temp  %>% melt()
  plot_data$status = factor(paste(plot_data$expert_status, 
                                  plot_data$cell_status_svm, sep = ":"), 
                            levels = c("abnormal:abnormal", "normal:normal", "abnormal:normal", "normal:abnormal"))
  p = ggplot(plot_data, aes(x = variable, y = value, 
                            group = Well, 
                            color = status)) + 
    ylab("Intensity") +
    geom_line() + 
    facet_wrap(~cell_id, scales = "free_y") + 
    guides(color = guide_legend(title="Expert:Pred")) +
    scale_x_discrete(name = "Frame", 
                   breaks = c("Frame1", "Frame80", "Frame160"), 
                   labels = c(1, 80, 60))
  print(p)
}
dev.off()

#%>% dplyr::select(-c(cell_status_svm, expert_status))
```





















### ROC curve - a. training data
```{r}

roc_novel_cell <- roc(novel_cell_dt$cell_status_svm, svm_fit_cell$fitted)


data(aSAH)
rocobj <- roc(aSAH$outcome, aSAH$s100b)
rocobj2 <- roc(aSAH$outcome, aSAH$wfns)

library(ggplot2)
g <- ggroc(rocobj)
g
# with additional aesthetics:
ggroc(rocobj, alpha = 0.5, colour = "red", linetype = 2, size = 2)

# You can then your own theme, etc.
g + theme_minimal() + ggtitle("My ROC curve") + 
    geom_segment(aes(x = 1, xend = 0, y = 0, yend = 1), color="grey", linetype="dashed")

# And change axis labels to FPR/FPR
gl <- ggroc(rocobj, legacy.axes = TRUE)
gl
gl + xlab("FPR") + ylab("TPR") + 
    geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color="darkgrey", linetype="dashed")

# Multiple curves:
g2 <- ggroc(list(s100b=rocobj, wfns=rocobj2, ndka=roc(aSAH$outcome, aSAH$ndka)))
g2

```


### ROC curve - b. novel data
```{r}



```







